import numpy as np
import json
import galois
from commpy.channelcoding import Trellis, viterbi_decode

# ----------------------
# QPSK Hard + Soft Demod
# ----------------------
def qpsk_demodulate(symbols):
    """
    QPSK hard decision demodulation -> bits
    Gray mapping assumed.
    """
    bits = []
    for s in symbols:
        # Real part: 0 if >0 else 1
        bits.append(0 if s.real > 0 else 1)
        # Imag part: 0 if >0 else 1
        bits.append(0 if s.imag > 0 else 1)
    return np.array(bits, dtype=np.uint8)

def qpsk_soft_demod(symbols, noise_var):
    """
    QPSK soft decision demodulation -> LLRs.
    Uses proper scaling with noise variance.
    """
    llrs = []
    scale = 2.0 / noise_var
    for s in symbols:
        llrs.append(scale * s.real)   # LLR for first bit (I)
        llrs.append(scale * s.imag)   # LLR for second bit (Q)
    return np.array(llrs)

# ----------------------
# Metrics
# ----------------------
def calculate_ber_fer(decoded_bits, ref_bits, frame_size=None):
    """
    Compare decoded bits against reference bits and return BER and FER.
    """
    n = min(len(decoded_bits), len(ref_bits))
    decoded_bits = decoded_bits[:n]
    ref_bits = ref_bits[:n]

    # Bit errors
    bit_errors = np.sum(decoded_bits != ref_bits)
    ber = bit_errors / n if n > 0 else float("nan")

    # Frame errors
    if frame_size is None:
        frame_size = n  # treat as one big frame

    num_frames = n // frame_size
    fer_count = 0
    for i in range(num_frames):
        start, end = i*frame_size, (i+1)*frame_size
        if np.any(decoded_bits[start:end] != ref_bits[start:end]):
            fer_count += 1
    fer = fer_count / num_frames if num_frames > 0 else float("nan")

    return ber, fer, n, bit_errors

# ----------------------
# Evaluation
# ----------------------
def evaluate_debug(rx_samples, meta_content):
    print(f"Loaded {len(rx_samples)} complex samples")

    sps = meta_content["sps"]
    ground_truth_bits = np.array(meta_content["clean_bits"], dtype=np.uint8)
    snr_db = meta_content.get("snr_db", 12)  # fallback if not provided
    noise_var = 1.0 / (2 * (10**(snr_db/10)))  # per-dimension variance

    # --- 1. Symbol extraction ---
    symbols = rx_samples[::sps]
    print(f"Extracted {len(symbols)} symbols")

    # --- 2. Hard demod ---
    raw_bits = qpsk_demodulate(symbols)

    # --- 3. Soft demod + Viterbi ---
    soft_bits = qpsk_soft_demod(symbols, noise_var)

    # Conv. code: rate 1/2, constraint length 7, polynomials [133, 171] (octal)
    g_matrix = np.array([[0o133, 0o171]])
    trellis = Trellis(memory=np.array([6]), g_matrix=g_matrix)

    # Increase traceback depth for better FER
    viterbi_out = viterbi_decode(soft_bits, trellis, tb_depth=70, decoding_type="unquantized")

    # --- 4. RS(15,11) over GF(2^4) ---
    RS = galois.ReedSolomon(15, 11, field=galois.GF(2**4))

    # Pack bits into 4-bit symbols
    viterbi_trim = viterbi_out[: (len(viterbi_out)//4)*4]
    nibbles = np.packbits(viterbi_trim, bitorder="big").view(np.uint8)
    nibbles = np.unpackbits(nibbles, bitorder="big").reshape(-1,4)
    nibbles = np.array([int("".join(map(str,row)),2) for row in nibbles], dtype=int)

    num_codewords = len(nibbles)//15
    rs_decoded_bits = []

    for i in range(num_codewords):
        cw = nibbles[i*15:(i+1)*15]
        try:
            msg = RS.decode(cw)
        except galois.ReedSolomonError:
            msg = cw[:11]  # fallback
        # convert symbols back to bits
        for val in msg:
            bits = [(val >> (3-b)) & 1 for b in range(4)]
            rs_decoded_bits.extend(bits)

    rs_decoded_bits = np.array(rs_decoded_bits, dtype=np.uint8)

    # ----------------------
    # Results
    # ----------------------
    print("\n--- RESULTS ---")

    ber, fer, n, bit_errors = calculate_ber_fer(raw_bits, ground_truth_bits, frame_size=512)
    print(f"Raw hard demod → Compared: {n}, Errors: {bit_errors}, BER: {ber:.3e}, FER: {fer:.2f}")

    ber, fer, n, bit_errors = calculate_ber_fer(viterbi_out, ground_truth_bits, frame_size=512)
    print(f"After Viterbi → Compared: {n}, Errors: {bit_errors}, BER: {ber:.3e}, FER: {fer:.2f}")

    ber, fer, n, bit_errors = calculate_ber_fer(rs_decoded_bits, ground_truth_bits, frame_size=352)
    print(f"After Viterbi + RS(15,11) → Compared: {n}, Errors: {bit_errors}, BER: {ber:.3e}, FER: {fer:.2f}")

    # Save decoded bits
    np.save("reedsolomonsample001_12db.npy", rs_decoded_bits)
    print("\n✅ Decoded bits saved to 'reedsolomonsample001_12db.npy'")

    return rs_decoded_bits

# ----------------------
# Run
# ----------------------
if __name__ == "__main__":
    RX_PATH = "/Users/pavanaksshay/Dropbox/cubesat_dataset/phase3_coding/reed_solomon/snr_12db/sample_001/rx.npy"
    META_PATH = "/Users/pavanaksshay/Dropbox/cubesat_dataset/phase3_coding/reed_solomon/snr_12db/sample_001/meta.json"

    rx_samples = np.load(RX_PATH)
    with open(META_PATH, "r") as f:
        meta_content = json.load(f)

    evaluate_debug(rx_samples, meta_content)
